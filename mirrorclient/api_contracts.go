/*
Hedera Mirror Node REST API

The Mirror Node REST API offers the ability to query cryptocurrency transactions and account information from a Hedera managed mirror node.  Base url: [/api/v1](/api/v1)  OpenAPI Spec: [/api/v1/docs/openapi.yml](/api/v1/docs/openapi.yml)

API version: 0.89.0
Contact: mirrornode@hedera.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mirrorclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ContractsAPIService ContractsAPI service
type ContractsAPIService service

type ApiContractsCallRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractCallRequest *ContractCallRequest
}

func (r ApiContractsCallRequest) ContractCallRequest(contractCallRequest ContractCallRequest) ApiContractsCallRequest {
	r.contractCallRequest = &contractCallRequest
	return r
}

func (r ApiContractsCallRequest) Execute() (*ContractCallResponse, *http.Response, error) {
	return r.ApiService.ContractsCallExecute(r)
}

/*
ContractsCall Invoke a smart contract


Returns a result from EVM execution such as cost-free execution of read-only smart contract queries, gas estimation, and transient simulation of read-write operations. If `estimate` field is set to true gas estimation is executed. Currently we support only `latest` block.
[Link to Supported/Unsupported Operations Table](https://github.com/hashgraph/hedera-mirror-node/blob/main/docs/web3/README.md#supported/unsupported-operations)

The operations types which are not currently supported should return 501 error status.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiContractsCallRequest
*/
func (a *ContractsAPIService) ContractsCall(ctx context.Context) ApiContractsCallRequest {
	return ApiContractsCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractCallResponse
func (a *ContractsAPIService) ContractsCallExecute(r ApiContractsCallRequest) (*ContractCallResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractCallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ContractsCall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/call"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contractCallRequest == nil {
		return localVarReturnValue, nil, reportError("contractCallRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contractCallRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractActionsByTransactionIdOrHashRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	transactionIdOrHash string
	index *string
	limit *int32
	order *string
}

// The index of a contract action
func (r ApiGetContractActionsByTransactionIdOrHashRequest) Index(index string) ApiGetContractActionsByTransactionIdOrHashRequest {
	r.index = &index
	return r
}

// The maximum number of items to return
func (r ApiGetContractActionsByTransactionIdOrHashRequest) Limit(limit int32) ApiGetContractActionsByTransactionIdOrHashRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiGetContractActionsByTransactionIdOrHashRequest) Order(order string) ApiGetContractActionsByTransactionIdOrHashRequest {
	r.order = &order
	return r
}

func (r ApiGetContractActionsByTransactionIdOrHashRequest) Execute() (*ContractActionsResponse, *http.Response, error) {
	return r.ApiService.GetContractActionsByTransactionIdOrHashExecute(r)
}

/*
GetContractActionsByTransactionIdOrHash Get the contract actions from a contract on the network for a given transactionId or ethereum transaction hash

Returns a list of ContractActions for a contract's function executions for a given transactionId or ethereum transaction hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionIdOrHash Transaction Id or a 32 byte hash with optional 0x prefix
 @return ApiGetContractActionsByTransactionIdOrHashRequest
*/
func (a *ContractsAPIService) GetContractActionsByTransactionIdOrHash(ctx context.Context, transactionIdOrHash string) ApiGetContractActionsByTransactionIdOrHashRequest {
	return ApiGetContractActionsByTransactionIdOrHashRequest{
		ApiService: a,
		ctx: ctx,
		transactionIdOrHash: transactionIdOrHash,
	}
}

// Execute executes the request
//  @return ContractActionsResponse
func (a *ContractsAPIService) GetContractActionsByTransactionIdOrHashExecute(r ApiGetContractActionsByTransactionIdOrHashRequest) (*ContractActionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractActionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractActionsByTransactionIdOrHash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/results/{transactionIdOrHash}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionIdOrHash"+"}", url.PathEscape(parameterValueToString(r.transactionIdOrHash, "transactionIdOrHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractByIdRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractIdOrAddress string
	timestamp *[]string
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiGetContractByIdRequest) Timestamp(timestamp []string) ApiGetContractByIdRequest {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetContractByIdRequest) Execute() (*ContractResponse, *http.Response, error) {
	return r.ApiService.GetContractByIdExecute(r)
}

/*
GetContractById Get contract by id

Return the contract information given an id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractIdOrAddress The ID or hex encoded EVM address (with or without 0x prefix) associated with this contract.
 @return ApiGetContractByIdRequest
*/
func (a *ContractsAPIService) GetContractById(ctx context.Context, contractIdOrAddress string) ApiGetContractByIdRequest {
	return ApiGetContractByIdRequest{
		ApiService: a,
		ctx: ctx,
		contractIdOrAddress: contractIdOrAddress,
	}
}

// Execute executes the request
//  @return ContractResponse
func (a *ContractsAPIService) GetContractByIdExecute(r ApiGetContractByIdRequest) (*ContractResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/{contractIdOrAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractIdOrAddress"+"}", url.PathEscape(parameterValueToString(r.contractIdOrAddress, "contractIdOrAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractResultByIdAndTimestampRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractIdOrAddress string
	timestamp string
}

func (r ApiGetContractResultByIdAndTimestampRequest) Execute() (*ContractResultDetails, *http.Response, error) {
	return r.ApiService.GetContractResultByIdAndTimestampExecute(r)
}

/*
GetContractResultByIdAndTimestamp Get the contract result from a contract on the network executed at a given timestamp

Returns a single ContractResult for a contract's function executions at a specific timestamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractIdOrAddress The ID or hex encoded EVM address (with or without 0x prefix) associated with this contract.
 @param timestamp The timestamp at which the associated transaction reached consensus
 @return ApiGetContractResultByIdAndTimestampRequest
*/
func (a *ContractsAPIService) GetContractResultByIdAndTimestamp(ctx context.Context, contractIdOrAddress string, timestamp string) ApiGetContractResultByIdAndTimestampRequest {
	return ApiGetContractResultByIdAndTimestampRequest{
		ApiService: a,
		ctx: ctx,
		contractIdOrAddress: contractIdOrAddress,
		timestamp: timestamp,
	}
}

// Execute executes the request
//  @return ContractResultDetails
func (a *ContractsAPIService) GetContractResultByIdAndTimestampExecute(r ApiGetContractResultByIdAndTimestampRequest) (*ContractResultDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractResultDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractResultByIdAndTimestamp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/{contractIdOrAddress}/results/{timestamp}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractIdOrAddress"+"}", url.PathEscape(parameterValueToString(r.contractIdOrAddress, "contractIdOrAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", url.PathEscape(parameterValueToString(r.timestamp, "timestamp")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractResultByTransactionIdOrHashRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	transactionIdOrHash string
	nonce *int32
}

// Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. Default is 0 when not specified.
func (r ApiGetContractResultByTransactionIdOrHashRequest) Nonce(nonce int32) ApiGetContractResultByTransactionIdOrHashRequest {
	r.nonce = &nonce
	return r
}

func (r ApiGetContractResultByTransactionIdOrHashRequest) Execute() (*ContractResultDetails, *http.Response, error) {
	return r.ApiService.GetContractResultByTransactionIdOrHashExecute(r)
}

/*
GetContractResultByTransactionIdOrHash Get the contract result from a contract on the network for a given transactionId or ethereum transaction hash

Returns a single ContractResult for a contract's function executions for a given transactionId or ethereum transaction hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionIdOrHash Transaction Id or a 32 byte hash with optional 0x prefix
 @return ApiGetContractResultByTransactionIdOrHashRequest
*/
func (a *ContractsAPIService) GetContractResultByTransactionIdOrHash(ctx context.Context, transactionIdOrHash string) ApiGetContractResultByTransactionIdOrHashRequest {
	return ApiGetContractResultByTransactionIdOrHashRequest{
		ApiService: a,
		ctx: ctx,
		transactionIdOrHash: transactionIdOrHash,
	}
}

// Execute executes the request
//  @return ContractResultDetails
func (a *ContractsAPIService) GetContractResultByTransactionIdOrHashExecute(r ApiGetContractResultByTransactionIdOrHashRequest) (*ContractResultDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractResultDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractResultByTransactionIdOrHash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/results/{transactionIdOrHash}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionIdOrHash"+"}", url.PathEscape(parameterValueToString(r.transactionIdOrHash, "transactionIdOrHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nonce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonce", r.nonce, "")
	} else {
		var defaultValue int32 = 0
		r.nonce = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAllContractsResultsRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	from *string
	blockHash *string
	blockNumber *string
	internal *bool
	limit *int32
	order *string
	timestamp *[]string
	transactionIndex *int32
}

// Account ID or EVM address executing the contract
func (r ApiListAllContractsResultsRequest) From(from string) ApiListAllContractsResultsRequest {
	r.from = &from
	return r
}

// The block&#39;s hash
func (r ApiListAllContractsResultsRequest) BlockHash(blockHash string) ApiListAllContractsResultsRequest {
	r.blockHash = &blockHash
	return r
}

// The block&#39;s number
func (r ApiListAllContractsResultsRequest) BlockNumber(blockNumber string) ApiListAllContractsResultsRequest {
	r.blockNumber = &blockNumber
	return r
}

// Whether to include child transactions or not
func (r ApiListAllContractsResultsRequest) Internal(internal bool) ApiListAllContractsResultsRequest {
	r.internal = &internal
	return r
}

// The maximum number of items to return
func (r ApiListAllContractsResultsRequest) Limit(limit int32) ApiListAllContractsResultsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListAllContractsResultsRequest) Order(order string) ApiListAllContractsResultsRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiListAllContractsResultsRequest) Timestamp(timestamp []string) ApiListAllContractsResultsRequest {
	r.timestamp = &timestamp
	return r
}

// The transaction index in the block
func (r ApiListAllContractsResultsRequest) TransactionIndex(transactionIndex int32) ApiListAllContractsResultsRequest {
	r.transactionIndex = &transactionIndex
	return r
}

func (r ApiListAllContractsResultsRequest) Execute() (*ContractResultsResponse, *http.Response, error) {
	return r.ApiService.ListAllContractsResultsExecute(r)
}

/*
ListAllContractsResults List contract results from all contracts on the network

Returns a list of all ContractResults for all contract's function executions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAllContractsResultsRequest
*/
func (a *ContractsAPIService) ListAllContractsResults(ctx context.Context) ApiListAllContractsResultsRequest {
	return ApiListAllContractsResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractResultsResponse
func (a *ContractsAPIService) ListAllContractsResultsExecute(r ApiListAllContractsResultsRequest) (*ContractResultsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractResultsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListAllContractsResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.blockHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block.hash", r.blockHash, "")
	}
	if r.blockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block.number", r.blockNumber, "")
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	} else {
		var defaultValue bool = false
		r.internal = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	if r.transactionIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction.index", r.transactionIndex, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractLogsRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractIdOrAddress string
	index *string
	limit *int32
	order *string
	timestamp *[]string
	topic0 *[]string
	topic1 *[]string
	topic2 *[]string
	topic3 *[]string
}

// Contract log index
func (r ApiListContractLogsRequest) Index(index string) ApiListContractLogsRequest {
	r.index = &index
	return r
}

// The maximum number of items to return
func (r ApiListContractLogsRequest) Limit(limit int32) ApiListContractLogsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListContractLogsRequest) Order(order string) ApiListContractLogsRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiListContractLogsRequest) Timestamp(timestamp []string) ApiListContractLogsRequest {
	r.timestamp = &timestamp
	return r
}

// The first topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractLogsRequest) Topic0(topic0 []string) ApiListContractLogsRequest {
	r.topic0 = &topic0
	return r
}

// The second topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractLogsRequest) Topic1(topic1 []string) ApiListContractLogsRequest {
	r.topic1 = &topic1
	return r
}

// The third topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractLogsRequest) Topic2(topic2 []string) ApiListContractLogsRequest {
	r.topic2 = &topic2
	return r
}

// The fourth topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractLogsRequest) Topic3(topic3 []string) ApiListContractLogsRequest {
	r.topic3 = &topic3
	return r
}

func (r ApiListContractLogsRequest) Execute() (*ContractLogsResponse, *http.Response, error) {
	return r.ApiService.ListContractLogsExecute(r)
}

/*
ListContractLogs List contract logs from a contract on the network

Search the logs of a specific contract across multiple contract calls. Chained logs are not
included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
and span a time range of at most seven days.

## Ordering
The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.

Note: The default order for this API is currently DESC

## Filtering
When filtering there are some restrictions enforced to ensure correctness and scalability.

**The table below defines the restrictions and support for the endpoint**

| Query Param   | Comparison Operator | Support | Description           | Example |
| ------------- | ------------------- | ------- | --------------------- | ------- |
| index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
|               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
| timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
|               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y


Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractIdOrAddress The ID or hex encoded EVM address (with or without 0x prefix) associated with this contract.
 @return ApiListContractLogsRequest
*/
func (a *ContractsAPIService) ListContractLogs(ctx context.Context, contractIdOrAddress string) ApiListContractLogsRequest {
	return ApiListContractLogsRequest{
		ApiService: a,
		ctx: ctx,
		contractIdOrAddress: contractIdOrAddress,
	}
}

// Execute executes the request
//  @return ContractLogsResponse
func (a *ContractsAPIService) ListContractLogsExecute(r ApiListContractLogsRequest) (*ContractLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContractLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/{contractIdOrAddress}/results/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"contractIdOrAddress"+"}", url.PathEscape(parameterValueToString(r.contractIdOrAddress, "contractIdOrAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	if r.topic0 != nil {
		t := *r.topic0
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic0", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic0", t, "multi")
		}
	}
	if r.topic1 != nil {
		t := *r.topic1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic1", t, "multi")
		}
	}
	if r.topic2 != nil {
		t := *r.topic2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic2", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic2", t, "multi")
		}
	}
	if r.topic3 != nil {
		t := *r.topic3
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic3", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic3", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractResultsRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractIdOrAddress string
	blockHash *string
	blockNumber *string
	from *string
	internal *bool
	limit *int32
	order *string
	timestamp *[]string
	transactionIndex *int32
}

// The block&#39;s hash
func (r ApiListContractResultsRequest) BlockHash(blockHash string) ApiListContractResultsRequest {
	r.blockHash = &blockHash
	return r
}

// The block&#39;s number
func (r ApiListContractResultsRequest) BlockNumber(blockNumber string) ApiListContractResultsRequest {
	r.blockNumber = &blockNumber
	return r
}

// Account ID or EVM address executing the contract
func (r ApiListContractResultsRequest) From(from string) ApiListContractResultsRequest {
	r.from = &from
	return r
}

// Whether to include child transactions or not
func (r ApiListContractResultsRequest) Internal(internal bool) ApiListContractResultsRequest {
	r.internal = &internal
	return r
}

// The maximum number of items to return
func (r ApiListContractResultsRequest) Limit(limit int32) ApiListContractResultsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListContractResultsRequest) Order(order string) ApiListContractResultsRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiListContractResultsRequest) Timestamp(timestamp []string) ApiListContractResultsRequest {
	r.timestamp = &timestamp
	return r
}

// The transaction index in the block
func (r ApiListContractResultsRequest) TransactionIndex(transactionIndex int32) ApiListContractResultsRequest {
	r.transactionIndex = &transactionIndex
	return r
}

func (r ApiListContractResultsRequest) Execute() (*ContractResultsResponse, *http.Response, error) {
	return r.ApiService.ListContractResultsExecute(r)
}

/*
ListContractResults List contract results from a contract on the network

Returns a list of all ContractResults for a contract's function executions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractIdOrAddress The ID or hex encoded EVM address (with or without 0x prefix) associated with this contract.
 @return ApiListContractResultsRequest
*/
func (a *ContractsAPIService) ListContractResults(ctx context.Context, contractIdOrAddress string) ApiListContractResultsRequest {
	return ApiListContractResultsRequest{
		ApiService: a,
		ctx: ctx,
		contractIdOrAddress: contractIdOrAddress,
	}
}

// Execute executes the request
//  @return ContractResultsResponse
func (a *ContractsAPIService) ListContractResultsExecute(r ApiListContractResultsRequest) (*ContractResultsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractResultsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContractResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/{contractIdOrAddress}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"contractIdOrAddress"+"}", url.PathEscape(parameterValueToString(r.contractIdOrAddress, "contractIdOrAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block.hash", r.blockHash, "")
	}
	if r.blockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block.number", r.blockNumber, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.internal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internal", r.internal, "")
	} else {
		var defaultValue bool = false
		r.internal = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	if r.transactionIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction.index", r.transactionIndex, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractStateRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractIdOrAddress string
	limit *int32
	order *string
	slot *string
	timestamp *string
}

// The maximum number of items to return
func (r ApiListContractStateRequest) Limit(limit int32) ApiListContractStateRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListContractStateRequest) Order(order string) ApiListContractStateRequest {
	r.order = &order
	return r
}

// The slot&#39;s number
func (r ApiListContractStateRequest) Slot(slot string) ApiListContractStateRequest {
	r.slot = &slot
	return r
}

// The timestamp at which the contract state is
func (r ApiListContractStateRequest) Timestamp(timestamp string) ApiListContractStateRequest {
	r.timestamp = &timestamp
	return r
}

func (r ApiListContractStateRequest) Execute() (*ContractStateResponse, *http.Response, error) {
	return r.ApiService.ListContractStateExecute(r)
}

/*
ListContractState The contract state from a contract on the network

Returns a list of all contract's slots. If no timestamp is provided, returns the current state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractIdOrAddress The ID or hex encoded EVM address (with or without 0x prefix) associated with this contract.
 @return ApiListContractStateRequest
*/
func (a *ContractsAPIService) ListContractState(ctx context.Context, contractIdOrAddress string) ApiListContractStateRequest {
	return ApiListContractStateRequest{
		ApiService: a,
		ctx: ctx,
		contractIdOrAddress: contractIdOrAddress,
	}
}

// Execute executes the request
//  @return ContractStateResponse
func (a *ContractsAPIService) ListContractStateExecute(r ApiListContractStateRequest) (*ContractStateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractStateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContractState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/{contractIdOrAddress}/state"
	localVarPath = strings.Replace(localVarPath, "{"+"contractIdOrAddress"+"}", url.PathEscape(parameterValueToString(r.contractIdOrAddress, "contractIdOrAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	if r.slot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slot", r.slot, "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractsRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	contractId *string
	limit *int32
	order *string
}

// The ID of the smart contract
func (r ApiListContractsRequest) ContractId(contractId string) ApiListContractsRequest {
	r.contractId = &contractId
	return r
}

// The maximum number of items to return
func (r ApiListContractsRequest) Limit(limit int32) ApiListContractsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListContractsRequest) Order(order string) ApiListContractsRequest {
	r.order = &order
	return r
}

func (r ApiListContractsRequest) Execute() (*ContractsResponse, *http.Response, error) {
	return r.ApiService.ListContractsExecute(r)
}

/*
ListContracts List contract entities on network

Returns a list of all contract entity items on the network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListContractsRequest
*/
func (a *ContractsAPIService) ListContracts(ctx context.Context) ApiListContractsRequest {
	return ApiListContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractsResponse
func (a *ContractsAPIService) ListContractsExecute(r ApiListContractsRequest) (*ContractsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contract.id", r.contractId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractsLogsRequest struct {
	ctx context.Context
	ApiService *ContractsAPIService
	index *string
	limit *int32
	order *string
	timestamp *[]string
	topic0 *[]string
	topic1 *[]string
	topic2 *[]string
	topic3 *[]string
}

// Contract log index
func (r ApiListContractsLogsRequest) Index(index string) ApiListContractsLogsRequest {
	r.index = &index
	return r
}

// The maximum number of items to return
func (r ApiListContractsLogsRequest) Limit(limit int32) ApiListContractsLogsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListContractsLogsRequest) Order(order string) ApiListContractsLogsRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiListContractsLogsRequest) Timestamp(timestamp []string) ApiListContractsLogsRequest {
	r.timestamp = &timestamp
	return r
}

// The first topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractsLogsRequest) Topic0(topic0 []string) ApiListContractsLogsRequest {
	r.topic0 = &topic0
	return r
}

// The second topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractsLogsRequest) Topic1(topic1 []string) ApiListContractsLogsRequest {
	r.topic1 = &topic1
	return r
}

// The third topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractsLogsRequest) Topic2(topic2 []string) ApiListContractsLogsRequest {
	r.topic2 = &topic2
	return r
}

// The fourth topic associated with a contract log. Requires a timestamp range also be populated.
func (r ApiListContractsLogsRequest) Topic3(topic3 []string) ApiListContractsLogsRequest {
	r.topic3 = &topic3
	return r
}

func (r ApiListContractsLogsRequest) Execute() (*ContractLogsResponse, *http.Response, error) {
	return r.ApiService.ListContractsLogsExecute(r)
}

/*
ListContractsLogs List contracts logs across many contracts on the network

Search the logs across many contracts with multiple contract calls. Chained logs are not
included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
and span a time range of at most seven days.

## Ordering
The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.

Note: The default order for this API is currently DESC

## Filtering
When filtering there are some restrictions enforced to ensure correctness and scalability.

**The table below defines the restrictions and support for the endpoint**

| Query Param   | Comparison Operator | Support | Description           | Example |
| ------------- | ------------------- | ------- | --------------------- | ------- |
| index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
|               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
| timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
|               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y


Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListContractsLogsRequest
*/
func (a *ContractsAPIService) ListContractsLogs(ctx context.Context) ApiListContractsLogsRequest {
	return ApiListContractsLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractLogsResponse
func (a *ContractsAPIService) ListContractsLogsExecute(r ApiListContractsLogsRequest) (*ContractLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContractsLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/contracts/results/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.index != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index", r.index, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	if r.topic0 != nil {
		t := *r.topic0
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic0", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic0", t, "multi")
		}
	}
	if r.topic1 != nil {
		t := *r.topic1
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic1", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic1", t, "multi")
		}
	}
	if r.topic2 != nil {
		t := *r.topic2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic2", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic2", t, "multi")
		}
	}
	if r.topic3 != nil {
		t := *r.topic3
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topic3", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topic3", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
