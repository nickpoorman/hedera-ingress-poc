/*
Hedera Mirror Node REST API

The Mirror Node REST API offers the ability to query cryptocurrency transactions and account information from a Hedera managed mirror node.  Base url: [/api/v1](/api/v1)  OpenAPI Spec: [/api/v1/docs/openapi.yml](/api/v1/docs/openapi.yml)

API version: 0.89.0
Contact: mirrornode@hedera.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mirrorclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AccountsAPIService AccountsAPI service
type AccountsAPIService service

type ApiGetAccountByIdOrAliasOrEvmAddressRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	timestamp *[]string
	transactiontype *TransactionTypes
	transactions *bool
}

// The maximum number of items to return
func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Limit(limit int32) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Order(order string) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Timestamp(timestamp []string) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	r.timestamp = &timestamp
	return r
}

func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Transactiontype(transactiontype TransactionTypes) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	r.transactiontype = &transactiontype
	return r
}

// If provided and set to false transactions will not be included in the response
func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Transactions(transactions bool) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	r.transactions = &transactions
	return r
}

func (r ApiGetAccountByIdOrAliasOrEvmAddressRequest) Execute() (*AccountBalanceTransactions, *http.Response, error) {
	return r.ApiService.GetAccountByIdOrAliasOrEvmAddressExecute(r)
}

/*
GetAccountByIdOrAliasOrEvmAddress Get account by alias, id, or evm address

Return the account transactions and balance information given an account alias, an account id, or an evm address. The information will be limited to at most 1000 token balances for the account as outlined in HIP-367.
When the timestamp parameter is supplied, we will return transactions and account state for the relevant timestamp query. Balance information will be accurate to within 15 minutes of the provided timestamp query.
Historical stake and reward information is not currently available so these fields contain current data. Historical ethereum nonce information is also currently not available and may not be the exact value at a provided timestamp.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiGetAccountByIdOrAliasOrEvmAddressRequest
*/
func (a *AccountsAPIService) GetAccountByIdOrAliasOrEvmAddress(ctx context.Context, idOrAliasOrEvmAddress string) ApiGetAccountByIdOrAliasOrEvmAddressRequest {
	return ApiGetAccountByIdOrAliasOrEvmAddressRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return AccountBalanceTransactions
func (a *AccountsAPIService) GetAccountByIdOrAliasOrEvmAddressExecute(r ApiGetAccountByIdOrAliasOrEvmAddressRequest) (*AccountBalanceTransactions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountBalanceTransactions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.GetAccountByIdOrAliasOrEvmAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	if r.transactiontype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactiontype", r.transactiontype, "")
	}
	if r.transactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactions", r.transactions, "")
	} else {
		var defaultValue bool = true
		r.transactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	accountBalance *string
	accountId *string
	accountPublickey *string
	balance *bool
	limit *int32
	order *string
}

// The optional balance value to compare against
func (r ApiListAccountsRequest) AccountBalance(accountBalance string) ApiListAccountsRequest {
	r.accountBalance = &accountBalance
	return r
}

// The ID of the account to return information for
func (r ApiListAccountsRequest) AccountId(accountId string) ApiListAccountsRequest {
	r.accountId = &accountId
	return r
}

// The account&#39;s public key to compare against
func (r ApiListAccountsRequest) AccountPublickey(accountPublickey string) ApiListAccountsRequest {
	r.accountPublickey = &accountPublickey
	return r
}

// Whether to include balance information or not. If included, token balances are limited to at most 50 per account as outlined in HIP-367.
func (r ApiListAccountsRequest) Balance(balance bool) ApiListAccountsRequest {
	r.balance = &balance
	return r
}

// The maximum number of items to return
func (r ApiListAccountsRequest) Limit(limit int32) ApiListAccountsRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListAccountsRequest) Order(order string) ApiListAccountsRequest {
	r.order = &order
	return r
}

func (r ApiListAccountsRequest) Execute() (*AccountsResponse, *http.Response, error) {
	return r.ApiService.ListAccountsExecute(r)
}

/*
ListAccounts List account entities on network

Returns a list of all account entity items on the network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAccountsRequest
*/
func (a *AccountsAPIService) ListAccounts(ctx context.Context) ApiListAccountsRequest {
	return ApiListAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountsResponse
func (a *AccountsAPIService) ListAccountsExecute(r ApiListAccountsRequest) (*AccountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account.balance", r.accountBalance, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account.id", r.accountId, "")
	}
	if r.accountPublickey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account.publickey", r.accountPublickey, "")
	}
	if r.balance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balance", r.balance, "")
	} else {
		var defaultValue bool = true
		r.balance = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCryptoAllowancesByAccountIdRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	spenderId *string
}

// The maximum number of items to return
func (r ApiListCryptoAllowancesByAccountIdRequest) Limit(limit int32) ApiListCryptoAllowancesByAccountIdRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListCryptoAllowancesByAccountIdRequest) Order(order string) ApiListCryptoAllowancesByAccountIdRequest {
	r.order = &order
	return r
}

// The ID of the spender to return information for
func (r ApiListCryptoAllowancesByAccountIdRequest) SpenderId(spenderId string) ApiListCryptoAllowancesByAccountIdRequest {
	r.spenderId = &spenderId
	return r
}

func (r ApiListCryptoAllowancesByAccountIdRequest) Execute() (*CryptoAllowancesResponse, *http.Response, error) {
	return r.ApiService.ListCryptoAllowancesByAccountIdExecute(r)
}

/*
ListCryptoAllowancesByAccountId Get crypto allowances for an account info

Returns information for all crypto allowances for an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiListCryptoAllowancesByAccountIdRequest
*/
func (a *AccountsAPIService) ListCryptoAllowancesByAccountId(ctx context.Context, idOrAliasOrEvmAddress string) ApiListCryptoAllowancesByAccountIdRequest {
	return ApiListCryptoAllowancesByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return CryptoAllowancesResponse
func (a *AccountsAPIService) ListCryptoAllowancesByAccountIdExecute(r ApiListCryptoAllowancesByAccountIdRequest) (*CryptoAllowancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CryptoAllowancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListCryptoAllowancesByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}/allowances/crypto"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.spenderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spender.id", r.spenderId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNftByAccountIdRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	serialnumber *string
	spenderId *string
	tokenId *string
}

// The maximum number of items to return
func (r ApiListNftByAccountIdRequest) Limit(limit int32) ApiListNftByAccountIdRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListNftByAccountIdRequest) Order(order string) ApiListNftByAccountIdRequest {
	r.order = &order
	return r
}

// The nft serial number (64 bit type). Requires a tokenId value also be populated.
func (r ApiListNftByAccountIdRequest) Serialnumber(serialnumber string) ApiListNftByAccountIdRequest {
	r.serialnumber = &serialnumber
	return r
}

// The ID of the spender to return information for
func (r ApiListNftByAccountIdRequest) SpenderId(spenderId string) ApiListNftByAccountIdRequest {
	r.spenderId = &spenderId
	return r
}

// The ID of the token to return information for
func (r ApiListNftByAccountIdRequest) TokenId(tokenId string) ApiListNftByAccountIdRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiListNftByAccountIdRequest) Execute() (*Nfts, *http.Response, error) {
	return r.ApiService.ListNftByAccountIdExecute(r)
}

/*
ListNftByAccountId Get nfts for an account info

Returns information for all non-fungible tokens for an account.

## Ordering
When considering NFTs, their order is governed by a combination of their numerical **token.Id** and **serialnumber** values, with **token.id** being the parent column.
A serialnumbers value governs its order within the given token.id

In that regard, if a user acquired a set of NFTs in the order (2-2, 2-4 1-5, 1-1, 1-3, 3-3, 3-4), the following layouts illustrate the ordering expectations for ownership listing
1. **All NFTs in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
2. **All NFTs in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3, 1-1
3. **NFTs above 1-1 in ASC order**: 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
4. **NFTs below 3-3 in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4
5. **NFTs between 1-3 and 3-3 inclusive in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3

Note: The default order for this API is currently DESC

## Filtering
When filtering there are some restrictions enforced to ensure correctness and scalability.

**The table below defines the restrictions and support for the NFT ownership endpoint**

| Query Param   | Comparison Operator | Support | Description           | Example |
| ------------- | ------------------- | ------- | --------------------- | ------- |
| token.id      | eq                  | Y       | Single occurrence only. | ?token.id=X |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. | ?token.id=lte:X |
|               | gt(e)               | Y       | Single occurrence only. | ?token.id=gte:X |
| serialnumber  | eq                  | Y       | Single occurrence only. Requires the presence of a **token.id** query | ?serialnumber=Y |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **token.id** query | ?token.id=lte:X&serialnumber=lt:Y |
|               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **token.id** query | ?token.id=gte:X&serialnumber=gt:Y |
| spender.id    | eq                  | Y       | | ?spender.id=Z |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | | ?spender.id=lt:Z |
|               | gt(e)               | Y       | | ?spender.id=gt:Z |

Note: When searching across a range for individual NFTs a **serialnumber** with an additional **token.id** query filter must be provided.
Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiListNftByAccountIdRequest
*/
func (a *AccountsAPIService) ListNftByAccountId(ctx context.Context, idOrAliasOrEvmAddress string) ApiListNftByAccountIdRequest {
	return ApiListNftByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return Nfts
func (a *AccountsAPIService) ListNftByAccountIdExecute(r ApiListNftByAccountIdRequest) (*Nfts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Nfts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListNftByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}/nfts"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.serialnumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialnumber", r.serialnumber, "")
	}
	if r.spenderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spender.id", r.spenderId, "")
	}
	if r.tokenId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token.id", r.tokenId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStakingRewardsByAccountIdRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	timestamp *[]string
}

// The maximum number of items to return
func (r ApiListStakingRewardsByAccountIdRequest) Limit(limit int32) ApiListStakingRewardsByAccountIdRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListStakingRewardsByAccountIdRequest) Order(order string) ApiListStakingRewardsByAccountIdRequest {
	r.order = &order
	return r
}

// The consensus timestamp in seconds.nanoseconds format with an optional comparison operator
func (r ApiListStakingRewardsByAccountIdRequest) Timestamp(timestamp []string) ApiListStakingRewardsByAccountIdRequest {
	r.timestamp = &timestamp
	return r
}

func (r ApiListStakingRewardsByAccountIdRequest) Execute() (*StakingRewardsResponse, *http.Response, error) {
	return r.ApiService.ListStakingRewardsByAccountIdExecute(r)
}

/*
ListStakingRewardsByAccountId Get past staking reward payouts for an account

Returns information for all past staking reward payouts for an account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiListStakingRewardsByAccountIdRequest
*/
func (a *AccountsAPIService) ListStakingRewardsByAccountId(ctx context.Context, idOrAliasOrEvmAddress string) ApiListStakingRewardsByAccountIdRequest {
	return ApiListStakingRewardsByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return StakingRewardsResponse
func (a *AccountsAPIService) ListStakingRewardsByAccountIdExecute(r ApiListStakingRewardsByAccountIdRequest) (*StakingRewardsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StakingRewardsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListStakingRewardsByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}/rewards"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "desc"
		r.order = &defaultValue
	}
	if r.timestamp != nil {
		t := *r.timestamp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTokenAllowancesByAccountIdRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	spenderId *string
	tokenId *string
}

// The maximum number of items to return
func (r ApiListTokenAllowancesByAccountIdRequest) Limit(limit int32) ApiListTokenAllowancesByAccountIdRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListTokenAllowancesByAccountIdRequest) Order(order string) ApiListTokenAllowancesByAccountIdRequest {
	r.order = &order
	return r
}

// The ID of the spender to return information for
func (r ApiListTokenAllowancesByAccountIdRequest) SpenderId(spenderId string) ApiListTokenAllowancesByAccountIdRequest {
	r.spenderId = &spenderId
	return r
}

// The ID of the token to return information for
func (r ApiListTokenAllowancesByAccountIdRequest) TokenId(tokenId string) ApiListTokenAllowancesByAccountIdRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiListTokenAllowancesByAccountIdRequest) Execute() (*TokenAllowancesResponse, *http.Response, error) {
	return r.ApiService.ListTokenAllowancesByAccountIdExecute(r)
}

/*
ListTokenAllowancesByAccountId Get fungible token allowances for an account

Returns information for fungible token allowances for an account.

## Ordering
The order is governed by a combination of the spender id and the token id values, with spender id being the parent column.
The token id value governs its order within the given spender id.

Note: The default order for this API is currently ASC

## Filtering
When filtering there are some restrictions enforced to ensure correctness and scalability.

**The table below defines the restrictions and support for the endpoint**

| Query Param   | Comparison Operator | Support | Description           | Example |
| ------------- | ------------------- | ------- | --------------------- | ------- |
| spender.id    | eq                  | Y       | Single occurrence only. | ?spender.id=X |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. | ?spender.id=lte:X |
|               | gt(e)               | Y       | Single occurrence only. | ?spender.id=gte:X |
| token.id      | eq                  | Y       | Single occurrence only. Requires the presence of a **spender.id** query | ?token.id=lt:Y |
|               | ne                  | N       | | |
|               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **spender.id** query | ?spender.id=lte:X&token.id=lt:Y |
|               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **spender.id** query | ?spender.id=gte:X&token.id=gt:Y |

Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiListTokenAllowancesByAccountIdRequest
*/
func (a *AccountsAPIService) ListTokenAllowancesByAccountId(ctx context.Context, idOrAliasOrEvmAddress string) ApiListTokenAllowancesByAccountIdRequest {
	return ApiListTokenAllowancesByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return TokenAllowancesResponse
func (a *AccountsAPIService) ListTokenAllowancesByAccountIdExecute(r ApiListTokenAllowancesByAccountIdRequest) (*TokenAllowancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenAllowancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListTokenAllowancesByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}/allowances/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	if r.spenderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spender.id", r.spenderId, "")
	}
	if r.tokenId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token.id", r.tokenId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTokenRelationshipByAccountIdRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	idOrAliasOrEvmAddress string
	limit *int32
	order *string
	tokenId *string
}

// The maximum number of items to return
func (r ApiListTokenRelationshipByAccountIdRequest) Limit(limit int32) ApiListTokenRelationshipByAccountIdRequest {
	r.limit = &limit
	return r
}

// The order in which items are listed
func (r ApiListTokenRelationshipByAccountIdRequest) Order(order string) ApiListTokenRelationshipByAccountIdRequest {
	r.order = &order
	return r
}

// The ID of the token to return information for
func (r ApiListTokenRelationshipByAccountIdRequest) TokenId(tokenId string) ApiListTokenRelationshipByAccountIdRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiListTokenRelationshipByAccountIdRequest) Execute() (*TokenRelationshipResponse, *http.Response, error) {
	return r.ApiService.ListTokenRelationshipByAccountIdExecute(r)
}

/*
ListTokenRelationshipByAccountId Get token relationships info for an account

Returns information for all token relationships for an account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrAliasOrEvmAddress Account alias or account id or evm address
 @return ApiListTokenRelationshipByAccountIdRequest
*/
func (a *AccountsAPIService) ListTokenRelationshipByAccountId(ctx context.Context, idOrAliasOrEvmAddress string) ApiListTokenRelationshipByAccountIdRequest {
	return ApiListTokenRelationshipByAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		idOrAliasOrEvmAddress: idOrAliasOrEvmAddress,
	}
}

// Execute executes the request
//  @return TokenRelationshipResponse
func (a *AccountsAPIService) ListTokenRelationshipByAccountIdExecute(r ApiListTokenRelationshipByAccountIdRequest) (*TokenRelationshipResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenRelationshipResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListTokenRelationshipByAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounts/{idOrAliasOrEvmAddress}/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrAliasOrEvmAddress"+"}", url.PathEscape(parameterValueToString(r.idOrAliasOrEvmAddress, "idOrAliasOrEvmAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	} else {
		var defaultValue string = "asc"
		r.order = &defaultValue
	}
	if r.tokenId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token.id", r.tokenId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
